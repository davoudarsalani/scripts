#!/usr/bin/env bash

## @last-modified 1400-09-25 22:09:22 +0330 Thursday

function get_datetime {
    case "$1" in
            ymdhms )   printf '%(%Y%m%d%H%M%S)T\n'            ;; ## PREVIOUSLY: printf '%s\n' "$(date +%Y%m%d%H%M%S)"
            ymd )      printf '%(%Y%m%d)T\n'                  ;; ## PREVIOUSLY: printf '%s\n' "$(date +%Y%m%d)"
            hms )      printf '%(%H%M%S)T\n'                  ;; ## PREVIOUSLY: printf '%s\n' "$(date +%H%M%S)"
            seconds )  printf '%(%s)T\n'                      ;; ## PREVIOUSLY: printf '%s\n' "$(date +%s)"
            weekday )  printf '%(%A)T\n'                      ;; ## PREVIOUSLY: printf '%s\n' "$(date +%A)"
            jymdhms )  printf '%s\n' "$(jdate +%Y%m%d%H%M%S)" ;;
            jymd )     printf '%s\n' "$(jdate +%Y%m%d)"       ;;
            jhms )     printf '%s\n' "$(jdate +%H%M%S)"       ;;
            jseconds ) printf '%s\n' "$(jdate +%s)"           ;;
            jweekday ) printf '%s\n' "$(jdate +%A)"           ;;
    esac
}

function heading {
    source "$HOME"/scripts/gb-color

    echo -e "$(green "$@")"  ## JUMP_2 can't use printf as it returns literal foo\nbar if 'foo\nbar' is passed to it
}

function flag {
    source "$HOME"/scripts/gb-color

    echo -e "$(purple "$@")"  ## JUMP_2 can't use printf as it returns literal foo\nbar if 'foo\nbar' is passed to it
}

function action_now {
    source "$HOME"/scripts/gb-color

    echo -e "$(green '→') $(grey "$@")"  ## JUMP_2 can't use printf as it returns literal foo\nbar if 'foo\nbar' is passed to it
}

function accomplished {
    source "$HOME"/scripts/gb-color

    echo -e "$(green '✔') $(grey "$@")"  ## JUMP_2 can't use printf as it returns literal foo\nbar if 'foo\nbar' is passed to it
}

function wrap_fzf_choice {
    source "$HOME"/scripts/gb-color

    printf '%s %s %s\n' "$(brown '--=[')" "$@" "$(brown ']=--')"
}

function choose_file {
    ## NOTE stolen from "$HOME"/.fzf/shell/key-bindings.bash with modifications
    ##      any change you make here, make sure to apply the changes there too
    ## NOTE used also in ~/.config/lfrc

    local item

    eval "$FZF_CTRL_T_COMMAND" | sed "s#$HOME#~#" | FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS" fzf "$@" | \
    while read -r item; do
        item="$(head -2 <<< "$item" | tail -1)"
        printf '%s\n' "${item/\~/$HOME}"
    done
}

function choose_directory {
    ## NOTE stolen from "$HOME"/.fzf/shell/key-bindings.bash with modifications
    ##      any change you make here, make sure to apply the changes there too
    ## NOTE used also in ~/.config/lfrc

    ## usages:
    ##   choose_directory
    ##   choose_directory 'dir_name'  ## to limit the results

    local dir

    dir="$(eval "$FZF_ALT_C_COMMAND" | sed "s#$HOME#~#" | FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS --header ''" fzf)"
    printf '%q\n' "${dir/\~/$HOME}"
}

function pipe_to_fzf {
    ## usages:
    ##   item="$(pipe_to_fzf "${items[@]}")"
    ##   item="$(pipe_to_fzf "${items[@]}" 'header=my header')"

    local header last
    declare -a received=( "$@" )

    last="${received[-1]}"
    regex='^header='

    ## remove last member if it is a header
    [[ "$last" =~ $regex ]] && {
        header="${last#*=}"  ## JUMP_3 "${last/$regex}" works too but the latter one does not work for pipe_to_rofi and pipe_to_dmenu so we picked this way
        unset 'received[-1]'
    }

    printf '%s\n' "${received[@]}" | fzf --header "$header"
}

function pipe_to_rofi {
    ## usages:
    ##   item="$(pipe_to_rofi "${items[@]}")"
    ##   item="$(pipe_to_rofi "${items[@]}" 'header=my header' 'bg=red')"  ## NOTE header comes first
    ##   item="$(pipe_to_rofi "${items[@]}" 'header=my header')"
    ##   item="$(pipe_to_rofi "${items[@]}" 'bg=red')"

    local last theme header bg
    declare -a received=( "$@" )

    last="${received[-1]}"
    bg_regex='^bg='
    header_regex='^header='
    theme='onedark.rasi'

    ## NOTE as bg is passed as last arg, bg_regex should be checked first (e.i. before header_regex)
    [[ "$last" =~ $bg_regex ]] && {
        bg="${last#*=}"  ## JUMP_3 "${last/$bg_regex}" didn't work
        unset 'received[-1]'
        theme='onedark-red.rasi'
    }

    last="${received[-1]}"
    [[ "$last" =~ $header_regex ]] && {
        header="${last#*=}"  ## JUMP_3 "${last/$header_regex}" didn't work
        unset 'received[-1]'
    }

    printf '%s\n' "${received[@]}" | rofi -theme "$HOME"/.config/rofi/"$theme" -dmenu -i -p "$header"
}

function pipe_to_dmenu {
    ## usages:
    ##   item="$(pipe_to_dmenu "${items[@]}")"
    ##   item="$(pipe_to_dmenu "${items[@]}" 'header=my header' 'bg=red')"  ## NOTE header comes first
    ##   item="$(pipe_to_dmenu "${items[@]}" 'header=my header')"
    ##   item="$(pipe_to_dmenu "${items[@]}" 'bg=red')"

    local last header bg dmenusb
    declare -a received=( "$@" )

    last="${received[-1]}"
    bg_regex='^bg='
    header_regex='^header='
    theme='onedark.rasi'

    ## NOTE as bg is passed as last arg, bg_regex should be checked first (e.i. before header_regex)
    [[ "$last" =~ $bg_regex ]] && {
        bg="${last#*=}"  ## JUMP_3 "${last/$bg_regex}" didn't work
        unset 'received[-1]'
        dmenusb="$bg"
    }

    last="${received[-1]}"
    [[ "$last" =~ $header_regex ]] && {
        header="${last#*=}"  ## JUMP_3 "${last/$header_regex}" didn't work
        unset 'received[-1]'
    }

    printf '%s\n' "${received[@]}" | dmenu -i -l "$dmenulines" -nb "$dmenunb" -nf "$dmenunf" -sb "$dmenusb" -sf "$dmenusf" -fn "$dmenufn" -p "$header"
}

function lsblk_full {
    \lsblk -o NAME,LABEL,SIZE,UUID,FSTYPE,TYPE,MOUNTPOINT,OWNER,GROUP,MODE,MAJ:MIN,RM,RO
}

function mounted_drives {
    if [ "$1" ]; then
        printf '%s\n' "$(df -hT)"
    else
        printf '%s\n' "$(df -T -x devtmpfs -x tmpfs -x usbfs -x loop)"  ## -x ARG instances help get rid of unnecessary drives
    fi
}

function get_mountable_umountable {
    readarray -t mountable  < <(\lsblk -nro NAME,LABEL,SIZE,UUID,FSTYPE,TYPE,MOUNTPOINT | \grep -iE 'part $|rom $')
    readarray -t umountable < <(\lsblk -nro NAME,LABEL,SIZE,UUID,FSTYPE,TYPE,MOUNTPOINT | \grep -i '/tmp/')
}

function msgn {
    notify-send --urgency=normal "$1" "$2" -i "$3" -t 10000
}

function msgc {
    notify-send --urgency=critical "$1" "$2" -i "$3"
}

function copy_pacman_log {
    source "$HOME"/scripts/gb-color

    cp /var/log/pacman.log "$HOME"/linux/pacman.log
    msgn "<span color=\"${orange}\">/var/log/pacman.log</span> copied"
}

function clear_playlist {
    audtool --playlist-clear
}

function turn_off_shuffle {
    source "$HOME"/scripts/gb-audacious
    [ "$shuffle_status" == 'on'  ] && audtool --playlist-shuffle-toggle
}

function turn_on_shuffle {
    source "$HOME"/scripts/gb-audacious
    [ "$shuffle_status" == 'off' ] && audtool --playlist-shuffle-toggle
}

function play_shutdown_track {
    source "$HOME"/scripts/gb-audio
    pacmd play-file "$HOME"/linux/sounds/shutdown.ogg "$def_sink_index"
}

function ago {
    ## usage:
    ##     ago "$arg1" "$arg2"
    ##           ^        ^-- now (in 1556867231 format)
    ##           '-- start date (in 2019-05-03T07:07:11Z format)

    local start_date_in_seconds now_in_seconds

    ## convert start time from 2019-05-03T07:07:11Z to 1556867231
    start_date_in_seconds="$(convert_to_second "$1")"
    now_in_seconds="$2"

    printf '%s ago\n' "$(convert_second "(( now_in_seconds - start_date_in_seconds ))" 'verbose')"
}

function convert_to_second {  ## convert 2021-04-15T11:10:03+0430 to 1618468803
    printf '%s\n' "$(date --date "$1" '+%s')"
}

function convert_second {
    local seconds sec min hour day mont year result

    seconds="${1%.*}"  ## remove decimal in case arg is a float
    sec="$(printf  "%02d" "$(( "$seconds" % 60 ))")"
    min="$(printf  "%02d" "$(( "$seconds" / 60 % 60 ))")"
    hour="$(printf "%02d" "$(( "$seconds" / 3600 % 24 ))")"
    day="$(printf  "%02d" "$(( "$seconds" / 3600 / 24 % 30 ))")"
    mont="$(printf "%02d" "$(( "$seconds" / 3600 / 24 / 30 % 12 ))")"
    year="$(printf "%02d" "$(( "$seconds" / 3600 / 24 / 30 / 12 ))")"

    if (( year == 0 )) && (( mont == 0 )) && (( day == 0 )); then
        if [ "$2" == 'verbose' ]; then
            result="$hour hours, $min minutes and $sec seconds"
        else
            result="${hour}:${min}:${sec}"
        fi
    elif (( year == 0 )) && (( mont == 0 )); then
        if [ "$2" == 'verbose' ]; then
            result="$day days, $hour hours, $min minutes and $sec seconds"
        else
            result="${day}:${hour}:${min}:${sec}"
        fi
    elif (( year == 0 )); then
        if [ "$2" == 'verbose' ]; then
            result="$mont months, $day days, $hour hours, $min minutes and $sec seconds"
        else
            result="${mont}:${day}:${hour}:${min}:${sec}"
        fi
    else
        if [ "$2" == 'verbose' ]; then
            result="$year years, $mont months, $day days, $hour hours, $min minutes and $sec seconds"
        else
            result="${year}:${mont}:${day}:${hour}:${min}:${sec}"
        fi
    fi

    ## remove items whose values are 00, and adjust comma and 'and'
    ## NOTE the same modifications in here and JUMP_4 are applied in convert_second function in gp.py, so
    ##      any changes you make here, make aure to update that too
    result="$(printf '%s\n' "$result" | \
        sed 's|00 [a-z]\+s, ||g' | \
        sed 's|00 [a-z]\+s and ||' | \
        sed 's|00 [a-z]\+s$||' | \
        sed 's|, \([0-9][0-9] [a-z]\+s \)| and \1|' | \
        sed 's|and 00 [a-z]\+s ||' | \
        sed 's| and $||' | \
        sed 's|, \([0-9][0-9] [a-z]\+\)$| and \1|' | \
        sed 's| and \([0-9][0-9] [a-z]\+\) and|, \1 and|g' | \
        sed 's|, \+$||' | \
        sed 's|, \([0-9][0-9] [a-z]\+s\)$| and \1|' \
    )"

    ## remove plural s when value is 01 JUMP_4
    result="$(printf '%s\n' "$result" | sed 's|\(01 [a-z]\+\)s |\1 |g;s|\(01 [a-z]\+\)s, |\1, |g;s|\(01 [a-z]\+\)s$|\1|')"

    printf '%s\n' "$result"
}

function clear_clipboard {
    greenclip clear
    msgn 'cleared' '' "$HOME"/linux/themes/greenclip.png
}

function random_wallpaper {
    local current_wallpaper_file rand_wall

    current_wallpaper_file=/tmp/current_wallpaper
    ## same wallpaper for both screens
    rand_wall="$(shuf -n 1 < <(find "$HOME"/wallpapers -mindepth 1 -maxdepth 1 -type f -iname '*.jpg'))"  ## JUMP_1
    printf '%s\n' "${rand_wall##*/}" > "$current_wallpaper_file"
    feh --bg-scale "$rand_wall"
}

function copy_random_wallpaper_for_startup {
    source "$HOME"/scripts/gb-color
    local rand_wall

    rand_wall="$(shuf -n 1 < <(find "$HOME"/wallpapers -mindepth 1 -maxdepth 1 -type f -iname '*.jpg'))"  ## JUMP_1
    sudo cp "$rand_wall" /usr/share/wallpapers/startup_background.jpg
    msgn "<span color=\"${orange}\">${rand_wall##*/}</span> copied"
}

function set_widget {
    ## only the awesome-widgets use this function but it'd better be here (rather than the script itself)
    ## because sometimes it's needed by 0-test

    local widget attr value

    widget="$1"
    attr="$2"
    value="$3"

    awesome-client "${widget}.${attr} = '${value}'"  ## NOTE do NOT change quotes
}

function get_input {
    source "$HOME"/scripts/gb-color
    local input

    unset input
    read -p "$(olive "$@") " input
    printf '%s\n' "$input"
}

function get_single_input {
    source "$HOME"/scripts/gb-color
    local single_input

    unset single_input
    read -p "$(olive "$@") " -n 1 single_input
    printf '%s\n' "$single_input"
}

function line {
    source "$HOME"/scripts/gb-color

    grey "$(printf "%$(tput cols)s\n" | sed "s/ /▬/g")"
}

function rand_str {
    printf '%s\n' "$(mktemp --dry-run | sed 's/.*\.//g')"  ## returns e.g. leQPAUyfZP

    # sed 's/-//g' < /proc/sys/kernel/random/uuid  ## returns e.g. a8a29c0d109a40468051bcbaf70af17e
}


function set_timezone {
    sudo ln -fs /usr/share/zoneinfo/Asia/Tehran /etc/localtime
    sudo hwclock --systohc --utc
    sudo timedatectl set-ntp true
}

function install_jcal {
    printf 'Dependencies: automake libtool build-essential libjalali-dev\n\n'
    git clone https://github.com/ashkang/jcal.git
    cd ./jcal/sources
    ./autogen.sh
    ./configure
    make
    sudo make install
    sudo /sbin/ldconfig
}


 # function find_duplicate_images {
 #     source "$HOME"/scripts/gb-color

 #     declare -a pics

 #     [ "$1" ] || {
 #         red 'arg needed'
 #         exit
 #     }
 #     dest_dir="$1"
 #     [ -d "$dest_dir" ] || {
 #         red 'no such dir'
 #         exit
 #     }

 #     SECONDS=0

 #     readarray -t pics < <(find "$dest_dir" -mindepth 1 -maxdepth 1 -type f -iname '*.jpg' | sort)
 #     dups=''

 #     for ((i=0; i<"${#pics[@]}"; i++)); {
 #         p1="${pics[$i]}"

 #         ## start comparing only if p1 is not already in dups
 #         if_p1_in_dups="$(printf '%s\n' "$dups" | \grep "$p1")"  ## I quoted $p1 and didn't check if it still works
 #         [ "$if_p1_in_dups" ] || {
 #             printf '%s\n' "$p1"
 #             for p2 in "${pics[@]:$i}"; {
 #                 ## prevent comparing with itself
 #                 [ "$p1" == "$p2" ] || {
 #                     difference="$(diff "$p1" "$p2")"
 #                     \grep -q 'differ$' <<< "$difference" || dups+="${p1} = ${p2}, "
 #                 }
 #             }

 #             ## write dups already found if any
 #             [ "$dups" ] && green "dups: $dups"

 #             grey '-------------------------'

 #         }
 #     }

 #     green "dups: $dups"
 #     printf '\n'

 #     dur="$(convert_second "$SECONDS")"
 #     printf 'Total duration: %s\n' "$dur"
 # }

 # function compare_network_speed {
 #    ## this function takes only one arg which can only be either old or new

 #    source "$HOME"/scripts/gb-calculation
 #    source "$HOME"/scripts/gb-color

 #    declare -a loop_durs loops_durs

 #    durs_file=/tmp/0-durs
 #    totals_file=/tmp/0-totals
 #    loops_count=10
 #    position="$1"

 #    [ "$position" == 'old' ] || [ "$position" == 'new' ] || {
 #        printf '%s\n' "$(red "arg can only be either old or new")"
 #        exit
 #    }

 #    ## if position is old it means we want to have a fresh start
 #    ## so let's empty totals_file first
 #    [ "$position" == "old" ] && > "$totals_file"

 #    for ((i=1; i<="$loops_count"; i++)); {
 #        printf 'loop %s\n' "$i"
 #        > "$durs_file"
 #        for ((j=1; j<="$loops_count"; j++)); {
 #            { time -p "$HOME"/scripts/awesome-widgets network ;} &>>"$durs_file"
 #            printf '\n' >> "$durs_file"
 #            sleep 1
 #        }

 #        loop_dur=0
 #        readarray -t loop_durs < <(\grep 'real' "$durs_file" | awk '{print $NF}')
 #        for a_sm in "${loop_durs[@]}"; {
 #            loop_dur="$(float_pad "${loop_dur}+${a_sm}" 1 2)"
 #        }
 #        printf '%s %s\n' "$position" "$loop_dur" >> "$totals_file"
 #    }

 #    loops_dur=0
 #    readarray -t loops_durs < <(\grep "$position" "$totals_file" | awk '{print $NF}')
 #    for a_big in "${loops_durs[@]}"; {
 #        loops_dur="$(float_pad "${loops_dur}+${a_big}" 1 2)"
 #    }
 #    printf '%s = %s\n\n' "$position" "$loops_dur" >> "$totals_file"

 #    ## compare
 #    old_loops_total="$(\grep 'old =' "$totals_file" | awk '{print $NF}' 2>/dev/null)"
 #    new_loops_total="$(\grep 'new =' "$totals_file" | awk '{print $NF}' 2>/dev/null)"

 #    [ "$new_loops_total" ] && [ "$old_loops_total" ] && {
 #        is_faster="$(compare_floats "$new_loops_total" '<' "$old_loops_total")"
 #        is_slower="$(compare_floats "$new_loops_total" '>' "$old_loops_total")"
 #        if [ "$is_faster" == 'true' ]; then
 #            diff="$(float_pad "${old_loops_total}-${new_loops_total}")"
 #            msg="$diff faster"
 #        elif [ "$is_slower" == 'true' ]; then
 #            diff="$(float_pad "${new_loops_total}-${old_loops_total}")"
 #            msg="$diff slower"
 #        else
 #            msg="$old_loops_total = $new_loops_total"
 #        fi
 #        printf 'compare\n%s\n' "$msg" >> "$totals_file"
 #    }
# }

# function convert_Fun_to_lower_size {
#     declare -a pics
#
#     old_fun="$HOME"/website/Files/Fun
#     new_fun="$HOME"/downloads/New_Fun
#     if [ -d "$new_fun" ]; then
#         rm "$new_fun"/*
#     else
#         mkdir "$new_fun"
#     fi

#     readarray -t pics < <(find "$old_fun" -mindepth 1 -maxdepth 1 -type f -iname '*.jpg' | sort)

#     for p in "${pics[@]##*/}"; {
#         printf '%s\n' "$p"
#         orig_p="$old_fun"/"$p"
#         new_p="$new_fun"/"$p"
#         ffmpeg -i "$orig_p" -q:a 1 -y "$new_p" 2>/dev/null
#     }
# }
# timer and record_* {{{
# function timer {
#     source "$HOME"/scripts/gb-color
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     start="$(get_datetime 'jhms')"
#     for ((i=1; i<="$1"; i++)); {
#         current="$(get_datetime 'jhms')"
#         (( seconds="current - start" ))
#         echo -en '\r  \r'
#         (( h="seconds / 3600 % 24" ))
#         (( m="seconds / 60 % 60" ))
#         (( s="seconds % 60" ))
#         w="$(printf "$2 %02d:%02d:%02d" "$h" "$m" "$s"  ## NOTE no \n ??
#         set_widget 'record' 'markup' "<span color=\"${red}\">${record_icon} <b>${w}</b></span>"
#         sleep 1
#     }
# }

# function record_audio {
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     timer "$3" "$4" &
#     ffmpeg -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default                \
#            -filter_complex amix=inputs=2      \
#            -t "$1" "$2" 2>/dev/null
# }

# function record_audio_ul {
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     ffmpeg -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default \
#            -filter_complex amix=inputs=2 \
#            "$1" 2>/dev/null
# }

# function record_screen {
#     source "$HOME"/scripts/gb-screen
#     timer "$3" "$6" &
#     ffmpeg -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default \
#            -filter_complex amix=inputs=2 \
#            -f x11grab -r 30 -s "$4" -i :0.0+"$5",0 \
#            -vcodec libx264 -preset veryfast -crf 18 -acodec libmp3lame -q:a 1 -pix_fmt yuv420p \
#            -t "$1" "$2" 2>/dev/null
# }

# function record_screen_ul {
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     ffmpeg -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default \
#            -filter_complex amix=inputs=2 \
#            -f x11grab -r 30 -s "$2" -i :0.0+"$3",0 \
#            -vcodec libx264 -preset veryfast -crf 18 -acodec libmp3lame -q:a 1 -pix_fmt yuv420p \
#            "$1" 2>/dev/null
# }

# function record_video {
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     timer "$3" "$4" &
#     ffmpeg -f v4l2 -framerate 25 -video_size 1366x768 -i "$def_video_dev" \
#            -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default \
#            -filter_complex amix=inputs=2 \
#            -t "$1" "$2" 2>/dev/null
# }

# function record_video_ul {
#     source "$HOME"/scripts/gb-screen
#     source "$HOME"/scripts/gb-audio
#     ffmpeg -f v4l2 -framerate 25 -video_size 1366x768 -i "$def_video_dev" \
#            -f pulse -i "$def_source_mon_index" \
#            -f pulse -i default \
#            -filter_complex amix=inputs=2 \
#            "$1" 2>/dev/null
# }

# function record_mic_mon_on {
#     source "$HOME"/scripts/gb-audio
#     unmute_mic
#     mic_25
#     unmute_mon
#     mon_100
# }

# function record_mon_on {
#     source "$HOME"/scripts/gb-audio
#     unmute_mon
#     mon_100
# }

# function record_mic_mon_off {
#     source "$HOME"/scripts/gb-audio
#     mute_mic
#     mic_0
#     mute_mon
#     mon_0
# }
