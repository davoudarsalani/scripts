#!/usr/bin/env bash

## last modified: 1400-09-11 13:32:53 +0330 Thursday

threshhold=70

case "$1" in
    rand_wall )  ## {{{
                source "$HOME"/scripts/gb

                rand_wall_allowed_file=/tmp/rand_wall_allowed

                [ -f "$rand_wall_allowed_file" ] && \
                [ ! "$(pgrep 'vlc')" ] && \
                [ ! "$(pgrep 'ffmpeg')" ] && \
                [ ! "$(ps -f -u "$UID" | sed 1d | \grep -v '\-remote' | \grep '[s]implescreenrecorder')" ] && \
                random_wallpaper || touch "$rand_wall_allowed_file" ;;  ## ^^ exceptionally used ps because pgrep cannot find simplescreenrecorder
                ## }}}
    jadi )  ## {{{
           "$HOME"/scripts/jadi.py ;;
           ## }}}
    restart_picom )  ## {{{
                    pkill picom && sleep 2 && picom -b ;;
                    ## }}}
    turn_off_scr_3 )  ## {{{
                     source "$HOME"/scripts/gb
                     source "$HOME"/scripts/gb-screen

                     [ "$scr_3_name" ] && {
                         xrandr --output "$scr_3_name" --off  ## https://superuser.com/questions/618127/disable-unplugged-displays-xrandr
                         msgn "turned off <span color=\"${orange}\">screen 3 (${scr_3_name})</span>"
                     } ;;
                     ## }}}

    date_jdate )  ## {{{
                 source "$HOME"/scripts/gb

                 message="$(printf '%s\n%s\n%s' "$(get_datetime 'jweekday')" "$(get_datetime 'ymdhms')" "$(get_datetime 'jymdhms')")"
                 msgn "$message" ;;
                ## }}}
    weather )  ## {{{
              case "$2" in
                  update )   "$HOME"/scripts/weather.py 'update'   ;;
                  forecast ) "$HOME"/scripts/weather.py 'forecast' ;;
              esac ;;
              ## }}}
    audio )  ## {{{
            source "$HOME"/scripts/gb

            function update_variables {
                source "$HOME"/scripts/gb-audio
            }

            update_variables

            function mute_vol {
                pactl set-sink-mute "$def_sink_index" 1  ## OR pactl set-sink-mute "$def_sink_index" true  <--,
            }                                            ##                                                   |
                                                         ##                                                   |
            function unmute_vol {                       ##                                                   |
                pactl set-sink-mute "$def_sink_index" 0  ## OR pactl set-sink-mute "$def_sink_index" false <--'-- pactl set-sink-mute "$def_sink_index" toggle
            }


            function mute_mic {
                pactl set-source-mute "$def_source_index" 1
            }

            function unmute_mic {
                pactl set-source-mute "$def_source_index" 0
            }

            # function mic_0 {
            #     pactl set-source-volume "$def_source_index" 0%
            # }

            # function mic_25 {
            #     pactl set-source-volume "$def_source_index" 25%
            # }

            function mute_mon {
                pactl set-source-mute "$def_source_mon_index" 1
            }

            function unmute_mon {
                pactl set-source-mute "$def_source_mon_index" 0
            }

            # function mon_0 {
            #     pactl set-source-volume "$def_source_mon_index" 0%
            # }

            # function mon_100 {
            #     pactl set-source-volume "$def_source_mon_index" 100%
            # }

            function connecttoheadset {
                source "$HOME"/scripts/gb-fir-blu-batt

                msgn "connecting to headset <span color=\"${orange}\">${headset_mac}</span>"

                local output="$(bluetoothctl connect "$headset_mac")"
                if [ ! "$(printf '%s\n' "$output" | \grep -i 'failed to connect')" ]; then
                    msgn "connected to <span color=\"${orange}\">${headset_mac}</span>"
                else
                    local text="$(printf "connecting to <span color=\"%s\">%s</span>\n%s\n" "$orange" "$headset_mac" "$output")"
                     msgc 'ERROR' "$text" "$HOME"/linux/themes/alert-w.png
                fi
            }

            case "$2" in
                vol_30 )     pactl set-sink-volume "$def_sink_index" 30% ;;

                toggle_vol ) if [ "$vol_mute_status" == 'yes' ]; then
                                 unmute_vol
                             else
                                 mute_vol
                             fi ;;
                vol_up )     pactl set-sink-volume "$def_sink_index" +5% ;;
                vol_down )   pactl set-sink-volume "$def_sink_index" -5% ;;
                # vol_100 )    pactl set-sink-volume "$def_sink_index" 100% ;;
                # vol_0 )      pactl set-sink-volume "$def_sink_index" 0% ;;

                toggle_mic ) if [ "$mic_mute_status" == 'yes' ]; then
                                 unmute_mic
                             else
                                 mute_mic
                             fi ;;
                mic_up )     pactl set-source-volume "$def_source_index" +5% ;;
                mic_down )   pactl set-source-volume "$def_source_index" -5% ;;
                mic_100 )    pactl set-source-volume "$def_source_index" 100% ;;
                mic_0 )      pactl set-source-volume "$def_source_index" 0% ;;

                toggle_mon ) if [ "$mon_mute_status" == 'yes' ]; then
                                 unmute_mon
                             else
                                 mute_mon
                             fi ;;
                mon_up )     pactl set-source-volume "$def_source_mon_index" +5% ;;
                mon_down )   pactl set-source-volume "$def_source_mon_index" -5% ;;
                mon_100 )    pactl set-source-volume "$def_source_mon_index" 100% ;;
                mon_0 )      pactl set-source-volume "$def_source_mon_index" 0% ;;

                connect_to_headset ) connecttoheadset ;;
                full_info )
text="$(printf '%s\n' "\
<span color=\"${orange}\">Vol</span>
name:   ${def_sink_name}
index:  ${def_sink_index}
level:  ${vol_level}
state:  ${vol_state}
mute:   ${vol_mute_status}

<span color=\"${orange}\">Mic</span>
name:   ${def_source_name}
index:  ${def_source_index}
level:  ${mic_level}
state:  ${mic_state}
mute:   ${mic_mute_status}

<span color=\"${orange}\">Mon</span>
name:   ${def_source_mon_name}
index:  ${def_source_mon_index}
level:  ${mon_level}
state:  ${mon_state}
mute:   ${mon_mute_status}

<span color=\"${orange}\">Active ports</span>
sink:   ${active_sink_port}
source: ${active_source_port}")"
msgn "$text" ;;
            esac

            update_variables

            [ "$vol_mute_status" == 'yes' ] && vol_on_off="<span color=\"${red}\">:OF</span>"
            (( vol_level == 0 )) && vol_level="<span color=\"${red}\">${vol_level}</span>"  || vol_level="$vol_level"

            [ "$mic_mute_status" == 'no' ] && mic_on_off="<span color=\"${red}\">:ON</span>"
            (( mic_level != 0 )) && mic_level="<span color=\"${red}\">${mic_level}</span>" || mic_level="$mic_level"


            [ "$mon_mute_status" == 'no' ] && mon_on_off="<span color=\"${red}\">:ON</span>"
            (( mon_level != 0 )) && mon_level="<span color=\"${red}\">${mon_level}</span>" || mon_level="$mon_level"

            states_initials="${vol_state::1}${mic_state::1}${mon_state::1}"  ## RSI
            indeces="${def_sink_index}${def_source_index}${def_source_mon_index}"  ## 010

            headset_regex='bluez_sink*'
            [[ "$def_sink_name" == $headset_regex ]] && headset_connectivity=' HE'  ## NOTE do not replace [[ with [, and do NOT quote $headset_regex
            ## previously: [ "$(printf '%s\n' "$def_sink_name" | \grep '^bluez_sink')" ] && headset_connectivity=' HE'

            set_widget 'audio' 'markup' "${vol_level}${vol_on_off} ${mic_level}${mic_on_off} ${mon_level}${mon_on_off} ${states_initials} ${indeces}${headset_connectivity}" ;;
            ## }}}
    battery )  ## {{{
              source "$HOME"/scripts/gb
              source "$HOME"/scripts/gb-fir-blu-batt

              if [ "$battery_level" ] && (( battery_level < 15 )); then  ## <--,-- sometimes battery_level is not present and, in spite of that,
                  set_widget 'battery_ct' 'fg' "$red"                    ##    |-- the (()) statement falsely returns true.
              else                                                       ##    '-- so we have to first check if battery_level is present
                  set_widget 'battery_ct' 'fg' "$fg_d"
              fi

              case "$battery_status" in
                  Full )        : ;;
                  Discharging ) : ;;
                  Charging )    ac_or_dc="<span color=\"${red}\">CH </span>" ;;
                  * )           ac_or_dc="<span color=\"${red}\">?? </span>" ;;
              esac

              ## get battery_temp_last
              battery_temp_last_file="$HOME"/scripts/.last/battery_temp
              battery_temp_last="$(< "$battery_temp_last_file")" || battery_temp_last=0  ## NOTE do NOT add 2>/dev/null
              ## save battery_temp as last for our next read
              printf '%s\n' "$battery_temp" > "$battery_temp_last_file"
              (( diff="battery_temp - battery_temp_last" ))
              if (( diff > 0 )); then
                  pref="+${diff} "
              elif (( diff < 0 )); then
                  pref="${diff} "
              fi

              [ "$battery_level" ] && battery_level="$battery_level "
              [ "$battery_rem" ] && battery_rem="$battery_rem "
              (( battery_temp > threshhold )) && battery_temp="<span color=\"${red}\">${battery_temp}</span>"

              set_widget 'battery' 'markup' "${ac_or_dc}${battery_level}${battery_rem}${pref}${battery_temp}Â°" ;;
              ## }}}
    memory_cpu )  ## {{{
        source "$HOME"/scripts/gb
        source "$HOME"/scripts/gb-calculation

        case "$2" in
            intensives ) top_memory="$(ps axch -o cmd:15,%mem --sort=-%mem | head -n 10)"  ## <--,-- 15 makes it only 15 characters long
                         top_cpu="$(ps axch -o cmd:15,%cpu --sort=-%cpu | head -n 10)"     ## <--'
                         message_text="$(printf "<span color=\"%s\">Memory</span>\n%s\n\n<span color=\"%s\">CPU</span>\n%s\n" "$orange" "$top_memory" "$orange" "$top_cpu")"
                         msgn "$message_text" ;;
            usage )  ## NOTE JUMP_3 memory should be calculated at the end becuase IFS=$ in memory section interferes with the calculations in cpu and cpu temperature

                    ## cpu (https://www.idnt.net/en-US/kb/941772)
                    ## get last usage
                    cpu_last_file="$HOME"/scripts/.last/cpu
                    cpu_sum_last_file="$HOME"/scripts/.last/cpu_sum
                    cpu_temp_last_file="$HOME"/scripts/.last/cpu_temp
                    read -a cpu_last < "$cpu_last_file" || cpu_last=( cpu 0 0 0 0 0 0 0 0 0 0 )  ## JUMP_2
                    cpu_sum_last="$(< "$cpu_sum_last_file")" || cpu_sum_last=0  ## NOTE do NOT add 2>/dev/null
                    cpu_temp_last="$(< "$cpu_temp_last_file")" || cpu_temp_last=0  ## NOTE do NOT add 2>/dev/null

                    ## get new usage
                    read -a cpu_now < /proc/stat               ## get the first line with aggregate of all cpus
                    cpu_sum="${cpu_now[@]:1}"                  ## get all columns but skip the first (which is the 'cpu' string)
                    ## ^^ cpu_sum is a str
                    (( cpu_sum="${cpu_sum// /+}" ))            ## replace the column seperator (space) with +
                    (( cpu_delta="cpu_sum - cpu_sum_last" ))   ## get the delta between two reads
                    (( cpu_idle="cpu_now[4] - cpu_last[4]" ))  ## get the idle time delta
                    (( cpu_used="cpu_delta - cpu_idle" ))      ## calc time spent working
                    cpu_perc="$(float_pad "100*${cpu_used}/${cpu_delta}" 1 2)"
                    ## save these as last to compare in our next read
                    printf '%s ' "${cpu_now[@]}" > "$cpu_last_file"  ## NOTE no \n
                    printf '\n' >> "$cpu_last_file"  ## NOTE JUMP_2 have to append new line (because none was appended in the previous line) otherwise it will exit non-zero when creating cpu_last and therefore activating pipe
                    printf '%s\n' "$cpu_sum" > "$cpu_sum_last_file"

                    cpu_geater="$(compare_floats "$cpu_perc" ">" "$threshhold")"
                    [ "$cpu_geater" == 'true' ] && cpu_perc="<span color=\"${red}\">${cpu_perc}</span>"

                    ## cpu temperature
                    cpu_temp="$(sensors | \grep 'Package' | cut -d '+' -f 2 |  cut -d '.' -f 1)"
                    ## save cpu_temp as last for our next read
                    printf '%s\n' "$cpu_temp" > "$cpu_temp_last_file"
                    (( diff="cpu_temp - cpu_temp_last" ))
                    if (( diff > 0 )); then
                        pref="+${diff} "
                    elif (( diff < 0 )); then
                        pref="${diff} "
                    fi
                    cpu_temp_greater="$(compare_floats "$cpu_temp" '>' "$threshhold")"
                    [ "$cpu_temp_greater" == 'true' ] && cpu_temp="<span color=\"${red}\">${cpu_temp}</span>"

                    ## cpu governor
                    readarray -t cpu_governor < <(for file in /sys/devices/system/cpu/cpu{0..3}/cpufreq/scaling_governor; {
                        [ -f "$file" -a -r "$file" ] || continue
                        cat "$file"
                    } | sort --unique)
                    [ "$(printf '%s\n' "${cpu_governor[@]}" | \grep -i 'powersave')" ] || cpu_gov=" <span color=\"${red}\">${cpu_governor[@]^^}</span>"

                    ## cpu governors (https://wiki.archlinux.org/title/CPU_frequency_scaling):
                    ## performance   Run the CPU at the maximum frequency.
                    ## powersave     Run the CPU at the minimum frequency.
                    ## userspace     Run the CPU at user specified frequencies.
                    ## ondemand      Scales the frequency dynamically according to current load. Jumps to the highest frequency and then possibly back off as the idle time increases.
                    ## conservative  Scales the frequency dynamically according to current load. Scales the frequency more gradually than ondemand.
                    ## schedutil     Scheduler-driven CPU frequency selection [2], [3].


                    ## memory  ## NOTE JUMP_3 memory should be calculated at the end becuase IFS=$ in memory section interferes with the calculations in cpu and cpu temperature
                    IFS=$
                    mem_info="$(< /proc/meminfo)"
                    mem_total="$(printf '%s\n'   "$mem_info" | \grep '^MemTotal'     | awk '{print $2}')"
                    mem_free="$(printf '%s\n'    "$mem_info" | \grep '^MemFree'      | awk '{print $2}')"
                    mem_buffers="$(printf '%s\n' "$mem_info" | \grep '^Buffers'      | awk '{print $2}')"
                    mem_cached="$(printf '%s\n'  "$mem_info" | \grep '^Cached'       | awk '{print $2}')"
                    mem_srec="$(printf '%s\n'    "$mem_info" | \grep '^SReclaimable' | awk '{print $2}')"

                    (( mem_used="mem_total - mem_free - mem_buffers - mem_cached - mem_srec" ))
                    mem_perc="$(float_pad "${mem_used}/${mem_total}*100" 1 2)"

                    mem_geater="$(compare_floats "$mem_perc" '>' "$threshhold")"
                    [ "$mem_geater" == 'true' ] && mem_perc="<span color=\"${red}\">${mem_perc}</span>"

                    set_widget 'memory_cpu' 'markup' "${cpu_pref}${mem_perc} ${cpu_perc} ${pref}${cpu_temp}Â°${cpu_gov}" ;;
        esac ;;
                 ## }}}
    harddisk )  ## {{{
        source "$HOME"/scripts/gb
        source "$HOME"/scripts/gb-calculation

        case "$2" in
            partitions ) partitions_text="$(printf "<span color=\"%s\">lsblk</span>\n%s\n\n<span color=\"%s\">mounted drives</span>\n%s\n" "$orange" "$(lsblk_full)" "$orange" "$(mounted_drives 'human_readable')")"
                         msgn "$partitions_text" ;;
            usage ) root_size="$(mounted_drives | \grep '\/$' | awk '{print $3}')"
                    root_used="$(mounted_drives | \grep '\/$' | awk '{print $4}')"
                    (( root_used > 0 )) && root_used="$(float_pad "${root_used}*100/${root_size}" 1 2)"
                    root_geater="$(compare_floats "$root_used" '>' "$threshhold")"
                    [ "$root_geater" == 'true' ] && root_used="<span color=\"${red}\">${root_used}</span>"

                    home_size="$(mounted_drives | \grep '\/home$' | awk '{print $3}')"
                    home_used="$(mounted_drives | \grep '\/home$' | awk '{print $4}')"
                    (( home_used > 0 )) && home_used="$(float_pad "${home_used}*100/${home_size}" 1 2)"
                    home_geater="$(compare_floats "$home_used" '>' "$threshhold")"
                    # [ "$home_geater" == 'true' ] && home_used="<span color=\"${red}\">${home_used}</span>"  ## TODO temporarily commented

                    swap_size="$(swapon --summary | \grep -i 'partition' | awk '{print $3}')"
                    swap_used="$(swapon --summary | \grep -i 'partition' | awk '{print $4}')"
                    (( swap_used > 0 )) && swap_used="$(float_pad "${swap_used}*100/${swap_size}" 1 2)"
                    swap_geater="$(compare_floats "$swap_used" '>' "$threshhold")"
                    [ "$swap_geater" == 'true' ] && swap_used="<span color=\"${red}\">${swap_used}</span>"

                    ## this is execptionally needed here because sometimes the swap_used in bytes is so small
                    ## that it becomes 0.00 after being converted by float_pad. If so, it's better to display it as 0:
                    swap_still_zero="$(compare_floats "$swap_used" '=' 0)"
                    [ "$swap_still_zero" == 'true' ] && swap_used=0


                    hdd_temp_last_file="$HOME"/scripts/.last/hdd_temp
                    hdd_temp_last="$(< "$hdd_temp_last_file")" || hdd_temp_last=0  ## NOTE do NOT add 2>/dev/null
                    hdd_temp="$(sudo hddtemp /dev/sda --numeric)"
                    ## save hdd_temp as last for our next read
                    printf '%s\n' "$hdd_temp" > "$hdd_temp_last_file"
                    (( diff="hdd_temp - hdd_temp_last" ))
                    if (( diff > 0 )); then
                        pref="+${diff} "
                    elif (( diff < 0 )); then
                        pref="${diff} "
                    fi

                    hdd_temp_geater="$(compare_floats "$hdd_temp" '>' "$threshhold")"
                    [ "$hdd_temp_geater" == 'true' ] && hdd_temp="<span color=\"${red}\">${hdd_temp}</span>"

                    set_widget 'harddisk' 'markup' "${root_used} ${home_used} ${swap_used} ${pref}${hdd_temp}Â°" ;;
        esac ;;
               ## }}}
    # gpu )  ## {{{
    #       source "$HOME"/scripts/gb
    #
    #       active_gpu="$(optimus-manager --status | \grep 'Current GPU mode' | awk '{print $NF}')"
    #       active_gpu="${active_gpu::1}"
    #       [ "$active_gpu" == 'n' ] && active_gpu="<span color=\"${red}\">${active_gpu}</span>"
    #       set_widget 'gpu' 'markup' "$active_gpu" ;;
            ## }}}
    pkg_count )  ## {{{
                source "$HOME"/scripts/gb

                pkg_count="$(wc -l < <(pacman -Q))"
                set_widget 'pkg_count' 'markup' "$pkg_count" ;;
                ## }}}
    processes )  ## {{{
                source "$HOME"/scripts/gb

                ## get last processes_count
                processes_last_file="$HOME"/scripts/.last/processes
                processes_count_last="$(< "$processes_last_file")" || processes_count_last=0  ## NOTE do NOT add 2>/dev/null

                processes_count="$(wc -l < <(pgrep .))"  ## previously: "$(wc -l < <(ps -aux))"
                ## save processes_count as last for our next read
                printf '%s\n' "$processes_count" > "$processes_last_file"

                ## compare
                (( diff="processes_count - processes_count_last" ))
                if (( diff > 0 )); then
                    pref="+${diff} "
                elif (( diff < 0 )); then
                    pref="${diff} "
                fi

                set_widget 'processes' 'markup' "${pref}${processes_count}" ;;
                ## }}}
    idle )  ## {{{
           source "$HOME"/scripts/gb
           source "$HOME"/scripts/gb-calculation

           weekday="$(get_datetime 'jweekday')"
           current_date="$(get_datetime 'jymd')"
           current_datetime="$(get_datetime 'jymdhms')"

           idle_file="$HOME"/linux/idle/idle-"$current_date"  ##    ,-- NOTE do NOT use printf '%02d\n' since it causes errors for 07 and 08 in day_hour_min_sec function
           (( idle_secs="$(xprintidle) / 1000" ))             ## <--'-- 103
           perc="$(float_pad "${idle_secs}*100/600" 1 2)"

           ## it's better to display perc as 0 if it is 0.00
           perc_is_zero="$(compare_floats "$perc" '=' 0)"
           [ "$perc_is_zero" == 'true' ] && perc=0

           printf '%s\t%s\t%s\n' "$current_datetime" "$weekday" "$perc" >> "$idle_file"
           is_bigger="$(compare_floats "$perc" '>' 90)"
           [ "$is_bigger" == 'true' ] && perc="<span color=\"${red}\">${perc}</span>"
           set_widget 'idle' 'markup' "$perc" ;;
           ## }}}
    reputation )  ## {{{
            "$HOME"/scripts/reputation.py ;;
            ## }}}
    youtube )  ## {{{
              source "$HOME"/scripts/gb
              source "$HOME"/scripts/gb-screen

              cur_scr_index="$(awesome-client 'local awful = require("awful") ; return awful.screen.focused().index' | awk '{print $NF}')"
              if (( cur_scr_index == 1 )); then
                  (( x="scr_1_x / 2" ))
              else
                  (( x="scr_1_x + (scr_2_x / 2)" ))
              fi
              y=300
              "$HOME"/scripts/awesome-widgets audacious pause
              xdotool mousemove "$x" "$y"
              sleep 0.1
              xdotool click --repeat 2 --delay 200 1
              msgn 'fullscreen' ;;
              ## }}}
    mbl_umbl )  ## {{{
               source "$HOME"/scripts/gb

               get_mountable_umountable
               m_count="${#mountable[@]}";  (( m_count > 0 )) && M="M:${m_count}"
               u_count="${#umountable[@]}"; (( u_count > 0 )) && U="U:${u_count}"
               (( m_count > 0 && u_count > 0 )) && seperator=','
               (( m_count > 0 || u_count > 0 )) && text="<span color=\"${red}\">${M}${seperator}${U}</span>" || text='MU'

               set_widget 'mbl_umbl' 'markup' "$text" ;;
               ## }}}
    firewall )  ## {{{
               source "$HOME"/scripts/gb

               function update_variables {
                   source "$HOME"/scripts/gb-fir-blu-batt
               }

               update_variables

               case "$2" in
                   turn_on )  sudo ufw enable  ;;
                   turn_off ) sudo ufw disable ;;
               esac

               update_variables

               case "$firewall_status" in
                   active ) set_widget 'firewall' 'markup' 'FI' ;;
                   * )      set_widget 'firewall' 'markup' "<span color=\"${red}\">FI:OF</span>" ;;
               esac ;;
               ## }}}
    bluetooth )  ## {{{
                source "$HOME"/scripts/gb

                function update_variables {
                    source "$HOME"/scripts/gb-fir-blu-batt
                }

                update_variables

                case "$2" in
                    turn_on )  sudo rfkill unblock bluetooth ;;
                    turn_off ) sudo rfkill block bluetooth   ;;
                esac

                update_variables

                case "$bluetooth_status" in
                    yes ) set_widget 'bluetooth' 'markup' 'BL' ;;
                    * )   set_widget 'bluetooth' 'markup' "<span color=\"${red}\">BL:ON</span>" ;;
                esac ;;
                ## }}}
    ymail )  ## {{{
            "$HOME"/scripts/e-mail.py 'ymail' ;;
            ## }}}
    gmail )  ## {{{
            sleep 10  ## only to prevent probable collision with ymail
            "$HOME"/scripts/e-mail.py 'gmail' ;;
            ## }}}
    security_remote )  ## {{{
                      "$HOME"/scripts/security-remote.py ;;
                      ## }}}
    webcam )  ## {{{
             source "$HOME"/scripts/gb

             webcam_status="$(lsmod | \grep -i '^uvcvideo' | awk '{print $NF}')"
             (( webcam_status == 0 )) && webcam_text='WE' || webcam_text="<span color=\"${red}\">WE:ON</span>"
             set_widget 'webcam' 'markup' "$webcam_text" ;;
             ## }}}
    git )  ## {{{
          source "$HOME"/scripts/gb
          source "$HOME"/scripts/gb-git

          modified_repos=''

          set_widget 'git' 'markup' "$refresh_icon"

          readarray -t all_repos      < <(git_repositories)
          readarray -t non_fdpo_repos < <(printf '%s\n' "${all_repos[@]/\~/$HOME}" | \grep -v 'git-fdpo')
          readarray -t fdpo_repos     < <(printf '%s\n' "${all_repos[@]/\~/$HOME}" | \grep    'git-fdpo')

          ## non-fdpo repos:
          for non_fdpo_repo in "${non_fdpo_repos[@]}"; {
              status_count="$(wc -l < <(git_status "$non_fdpo_repo"))"

              (( status_count > 0 )) && {
                  base="${non_fdpo_repo##*/}"
                  modified_repos+="${base::1}${status_count},"
              }
          }

          ## fdpo repos:
          regex_status='>ST:'
          regex_commits_ahead='>AH:'
          for fdpo_repo in "${fdpo_repos[@]%/.git}"; {
              base="${fdpo_repo##*/}"

              ## check if repo is ahead of origin
              commits_ahead="$(git_commits_ahead "$fdpo_repo")"
              (( commits_ahead > 0 )) && {
                  [[ ! "$modified_repos" =~ $regex_commits_ahead ]] && pref="$regex_commits_ahead"
                  modified_repos+=" ${pref}${base::1}${commits_ahead},"
                  unset pref
              }

              ## check if there are changes
              status_count="$(wc -l < <(git_status "$fdpo_repo"))"
              (( status_count > 0 )) && {
                  [[ ! "$modified_repos" =~ $regex_status ]] && pref="$regex_status"
                  modified_repos+=" ${pref}${base::1}${status_count},"
                  unset pref
              }

          }

          [ ! "$modified_repos" ] && git_text="GI" || git_text="<span color=\"${red}\">GI:${modified_repos%,*}</span>"  ## %,* is to remove the trailing , and everything coming after that (only one % mean non-greedy)
          set_widget 'git' 'markup' "$git_text" ;;
          ## }}}
    clipboard )  ## {{{
                source "$HOME"/scripts/gb

                case "$2" in
                    start ) greenclip daemon & ;;
                    stop )  pkill greenclip ;;
                esac

                [ "$(pgrep 'greenclip')" ] && clipboard_text='CL' || clipboard_text="<span color=\"${red}\">CL:OF</span>"
                set_widget 'clipboard' 'markup' "$clipboard_text" ;;
                ## }}}
    klgr )  ## {{{
           source "$HOME"/scripts/gb

           ## append current_datetime to the most recent log
           current_datetime="$(get_datetime 'jymdhms')"
           weekday="$(get_datetime 'jweekday')"
           most_recent_log="$(find "$HOME"/linux/keylogs/ -mindepth 1 -maxdepth 1 | sort | tail -n 1)"
           dashed="$(awk -v i=30 'BEGIN {OFS="-"; $i="-"; print}')"  ## NOTE do NOT replace " with '  ## https://www.unix.com/shell-programming-and-scripting/235829-how-print-particular-character-n-number-times-line.html
           printf '%s\n%s\t%s\n' "$dashed" "$current_datetime" "$weekday" >> "$most_recent_log"

           ## check status (exceptionally used ps because pgrep cannot find this)
           keylogger_status="$(ps -f -u "$UID" | sed 1d | \grep -v '\-remote' | \grep '[k]eylogger')"
           [ "$keylogger_status" ] && keylogger_text='KE' || keylogger_text="<span color=\"${red}\">KE:OF</span>"
           set_widget 'keylogger' 'markup' "$keylogger_text" ;;
           ## }}}
    established )  ## {{{
                  source "$HOME"/scripts/gb

                  ## we can add sudo in this case to get instances other than the user-related ones:
                  estab="$(sudo lsof -i -P -n | \grep 'ESTABLISHED' | awk '{print $1}' | sort --unique)"  ## -i looks for listing ports, -P inhibits the conversion of port numbers to port names for network files, -n does not use DNS name (https://www.cyberciti.biz/faq/how-to-check-open-ports-in-linux-using-the-cli/)
                  estab_count="$(wc -l < <(printf '%s\n' "${estab:?'NONE'}"))"  ## JUMP_1 --,--> expansion structure from https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                                                                                ##          '--> throws non-skippable error when estab nat available

                  (( estab_count == 0 )) && estab_text='ES' || estab_text="ES:${estab_count}"
                  set_widget 'established' 'markup' "$estab_text"

                  case "$2" in
                      message ) (( estab_count > 0 )) && message_text="$(printf "<span color=\"%s\">Established</span>\n%s\n" "$orange" "$estab")" || message_text='No established connections'
                                msgn "$message_text" ;;
                  esac ;;
                  ## }}}
    open_ports )  ## {{{
                 source "$HOME"/scripts/gb

                 ## FIXME
                 open_ports="$(sudo lsof -i -P -n | \grep 'LISTEN')"  ## -i looks for listing ports, -P inhibits the conversion of port numbers to port names for network files, -n does not use DNS name (https://www.cyberciti.biz/faq/how-to-check-open-ports-in-linux-using-the-cli/)
                 open_ports_count="$(wc -l < <(printf '%s\n' "${open_ports:?'NONE'}"))"  ## JUMP_1 --,--> expansion structure from https://stackoverflow.com/questions/3601515/how-to-check-if-a-variable-is-set-in-bash
                                                                                         ##          '--> throws non-skippable error when open_ports nat available
                 (( open_ports_count == 0 )) && open_ports_text='OP' || open_ports_text="<span color=\"${red}\">OP:${open_ports_count}</span>"
                 set_widget 'open_ports' 'markup' "$open_ports_text"

                 case "$2" in
                     message ) (( open_ports_count > 0 )) && message_text="$(printf "<span color=\"%s\">Open ports</span>\n%s\n" "$orange" "$open_ports")" || message_text='No open ports'
                               msgn "$message_text" ;;
                 esac ;;
                 ## }}}
    tor )  ## {{{
          source "$HOME"/scripts/gb

          case "$2" in
              start )   sudo systemctl start   tor && msgn "<span color=\"${orange}\">tor</span> started"   ;;
              stop )    sudo systemctl stop    tor && msgn "<span color=\"${orange}\">tor</span> stopped"   ;;
              restart ) sudo systemctl restart tor && msgn "<span color=\"${orange}\">tor</span> restarted" ;;
          esac

          tor_status="$(pgrep 'tor')"  ## why exceptionally used "$(sudo lsof -i -P -n | \grep 'LISTEN' | \grep '^tor')" instead of pgrep?
          [ "$tor_status" ] && tor_status_text="<span color=\"${red}\">TO:ON</span>" || tor_status_text='TO'
          set_widget 'tor' 'markup' "$tor_status_text" ;;
          ## }}}
    network )  ## {{{
        source "$HOME"/scripts/gb
        source "$HOME"/scripts/gb-calculation
        source "$HOME"/scripts/gb-network

        down_up_text=''

        case "$2" in
            usage )
                    # connections {{{
                    [ "$vpn_info" ] && vpn_conn="[${vpn_conn}] "
                    [ "$wf_conn" == 'MCI' ] && if_simcard=' SIM'
                    [ "$wf_state" == 'connected' ] || if_wf_down=' DOWN'

                    ## set wf_conn_color based on wf_strength
                    wf_strength="$(tail -n 1 /proc/net/wireless | awk '{print $4}' | tr -d '.')"
                    if   (( wf_strength < -75 )); then wf_conn_color="${orange}"
                    elif (( wf_strength < -50 )); then wf_conn_color="$yellow"
                    elif (( wf_strength < -25 )); then wf_conn_color="$fg_l"
                    elif (( wf_strength <   0 )); then wf_conn_color="$fg_l"
                    else                               wf_conn_color="$purple"
                    fi

                    connections_text="<span color=\"${fg_l}\">${vpn_conn}${eth_conn}</span> <span color=\"${wf_conn_color}\">${wf_conn}</span><span color=\"${orange}\">${if_simcard}${if_wf_down}</span>"
                    # connections_text="<span color=\"${fg_l}\">${vpn_conn}${eth_conn} ${wf_conn}</span>"
                    ## }}}
                    # down/up {{{ https://www.adminsehow.com/2010/03/shell-script-to-show-network-speed/
                    for interface in 'ethernet' 'wifi'; {

                        ## get last down/up
                        case "$interface" in
                            ethernet ) cur_interface="$eth_devc"; pref='eth' ;;
                            wifi )     cur_interface="$wf_devc"; pref='wf' ;;
                        esac
                        down_last_file="$HOME"/scripts/.last/network_"${pref}"_down
                        up_last_file="$HOME"/scripts/.last/network_"${pref}"_up

                        down_last="$(< "$down_last_file")" || down_last=0  ## 19410508  ## NOTE do NOT add 2>/dev/null
                        up_last="$(< "$up_last_file")" || up_last=0        ## 19410508  ## NOTE do NOT add 2>/dev/null

                        ## get new down/up
                        down_up="$(\grep "$cur_interface" /proc/net/dev | awk '{print "down="$2, "up="$10}')"  ## <-- NOTE do NOT replace " with ' in awk
                        eval "$down_up"  ## 19410509 789384

                        ## save new down/up as last (in bytes, before converting them) for our next read
                        printf '%s\n' "$down" > "$down_last_file"
                        printf '%s\n' "$up"   > "$up_last_file"

                        ## get+convert total down/up before converting down/up
                        down_total="$(convert_byte "$down")"  ## 4.32GB
                        up_total="$(convert_byte "$up")"      ## 4.32GB

                        ## set total down/up color
                        case "$down_total" in
                            # [0-9][0-9].*MB )      down_total_color="$grey_dark"  ;;  ## 00MB-99MB
                            # [1-3][0-9][0-9].*MB ) down_total_color="$grey_dark"  ;;  ## 100MB-399MB
                            [4-6][0-9][0-9].*MB ) down_total_color="$grey"       ;;  ## 400MB-699MB
                            [7-9][0-9][0-9].*MB ) down_total_color="$pink"       ;;  ## 700MB-999MB
                            *GB )                 down_total_color="$red"        ;;  ## *GB
                            * )                   down_total_color="$grey_dark"  ;;
                        esac

                        case "$up_total" in
                            # [0-9][0-9].*MB )      up_total_color="$grey_dark"  ;;  ## 00MB-99MB
                            # [1-3][0-9][0-9].*MB ) up_total_color="$grey_dark"  ;;  ## 100MB-399MB
                            [4-6][0-9][0-9].*MB ) up_total_color="$grey"       ;;  ## 400MB-699MB
                            [7-9][0-9][0-9].*MB ) up_total_color="$pink"       ;;  ## 700MB-999MB
                            *GB )                 up_total_color="$red"        ;;  ## *GB
                            * )                   up_total_color="$grey_dark"  ;;
                        esac

                        ## calculate diff and convert bytes
                        (( down_diff="down - down_last" ))    ## 1341440
                        (( up_diff="up - up_last" ))          ## 1341440
                        down="$(convert_byte "$down_diff")"   ## 1.31MB
                        up="$(convert_byte "$up_diff")"       ## 1.31MB

                        ## set down/up color
                        case "$down" in
                            # [0-9][0-9].*KB )        down_color="$fg_d"      ;;  ## 00MB-99KB
                            # [1-3][0-9][0-9].*KB )   down_color="$fg_d"      ;;  ## 100MB-399KB
                            [4-6][0-9][0-9].*KB )   down_color="$cyan_dark" ;;  ## 400MB-699KB
                            [7-9][0-9][0-9].*KB )   down_color="$cyan"      ;;  ## 700MB-999KB
                            *[MG]B )                down_color="$green"     ;;
                            * )                     down_color="$fg_d"      ;;
                        esac

                        case "$up" in
                            # [0-9][0-9].*KB )        up_color="$fg_d"      ;;  ## 00MB-99KB
                            # [1-3][0-9][0-9].*KB )   up_color="$fg_d"      ;;  ## 100MB-399KB
                            [4-6][0-9][0-9].*KB )   up_color="$cyan_dark" ;;  ## 400MB-699KB
                            [7-9][0-9][0-9].*KB )   up_color="$cyan"      ;;  ## 700MB-999KB
                            *[MG]B )                up_color="$green"     ;;
                            * )                     up_color="$fg_d"      ;;
                        esac

                        down_up_text+=" <span color=\"${down_color}\">${down}</span> <span color=\"${up_color}\">${up}</span> \
<span color=\"${down_total_color}\">${down_total}</span> <span color=\"${up_total_color}\">${up_total}</span>"   ## 317KB 2.31MB 4.32GB 4.32GB

                    }
## }}}
                    set_widget 'network' 'markup' "${connections_text} ${down_up_text# }"  ## remove leading space
                    ;;
            turn_on_wifi ) nmcli radio wifi on ;;
            turn_off_wifi ) nmcli radio wifi off ;;
        esac ;;
## }}}
    audacious )  ## {{{
                source "$HOME"/scripts/gb
                source "$HOME"/scripts/gb-calculation

                function update_variables {
                    source "$HOME"/scripts/gb-audacious
                }

                update_variables

                if [ "$album" == 'speech' ]; then
                    audtool --equalizer-set 0 0 0 0 0 0 0 0 0 0 0
                else
                    audtool --equalizer-set -2.10 -10.86 4.00 5.14 2.10 -0.19 -2.10 -2.86 -4.00 -4.00 -4.00
                fi

                case "$2" in
                    play_pause )  audtool --playback-playpause ;;  ## OR audacious -t
                    pause )       [ "$play_status" == 'playing' ] && audtool --playback-pause ;;
                    main_window ) audtool --mainwin-show ;;  ## OR audacious -H OR audacious -m
                    resume )      [ "$album" == 'speech' ] && audtool --playback-seek "$(< ${HOME}/scripts/.last/csols)" ;;
                    tog_shuff )   audtool --playlist-shuffle-toggle ;;
                    prev )        audtool --playlist-reverse ;;  ## OR audacious -r
                    next )        audtool --playlist-advance ;;  ## OR audacious -f
                    forward )     forward_length=120
                                  (( remaining_seconds="length_in_seconds - current_position_in_seconds" ))
                                  if (( remaining_seconds < forward_length )); then
                                      audtool --playlist-advance
                                  else
                                      audtool --playback-seek-relative "+${forward_length}"
                                  fi ;;
                    +60 )         audtool --playback-seek-relative +60 ;;
                    -60 )         audtool --playback-seek-relative -60 ;;
                    songs )       IFS=$'\n'
                                  readarray -t current_songs < <(audtool --playlist-display)
                                  selected_song="$(pipe_to_rofi "${current_songs[@]}" 'header=songs')" || exit 37

                                  selected_song_index="$(printf '%s\n' "$selected_song" | awk '{print $1}')"
                                  audtool --playlist-jump "$selected_song_index" ;;
                esac

                update_variables

                ## save currnt song output length seconds (csols) if speech
                regex='^(playing|paused)$'
                [[ "$play_status" =~ $regex ]] && [ "$album" == 'speech' ] && {
                    printf '%s\n' "$current_position_in_seconds" > "$HOME"/scripts/.last/csols
                    # msgn 'saved csol' "<span color=\"${orange}\">${current_position}</span>"
                }

                [ "$play_status" == 'playing' ] || pause_text='PAUSED '
                preamp_iz_zero="$(compare_floats "$preamp" '=' 0)"
                [ "$preamp_iz_zero" == 'false' ] && equalizer='EQ '
                [ "$shuffle_status" == 'on' ] && shuffle_text='SH '
                order="${position_in_playlist}/${playlist_length}"  ## 1/5
                [ ! "$length" ] && time='0:00/0:00' || time="${current_position}/${length}"  ## 2:24/18:54
                (( bar_position > 99 )) && bar_position=1 || bar_position=0.${bar_position}
                left="$(day_hour_min_sec "$left_in_seconds")"  ## 00:45:16
                ## remove leading 00: if left is less than one hour:
                [ "${left::3}" == '00:' ] && left="${left:3}"

                text="<span color=\"${grey}\">${pause_text}</span><span color=\"${fg_l}\">${equalizer}</span><span color=\"${fg_d}\">${shuffle_text}</span><span color=\"${fg_l}\">${order}</span> <span color=\"${fg_d}\">${time} -${left}</span> <span color=\"${fg_l}\">${title}</span> <span color=\"${fg_d}\">${album}</span> <span color=\"${fg_l}\">${artist}</span>"
                set_widget 'audacious'     'markup'           "$text"
                set_widget 'audacious_bar' 'background_color' "$fg_l"
                set_widget 'audacious_bar' 'color'            "$fg_d"
                awesome-client "audacious_bar.value = ${bar_position}"  ## set_widget doesn't work properly for audacious_bar
                ;;
                ## }}}
esac

exit
